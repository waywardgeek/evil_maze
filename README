This algorithm works as follows:

- Every time we explore through a series of unexplored rooms, and arrive at a room we'be
  seen before, we create a new "loop" consisting of the chain of newly explored rooms and
  the most recently visited rooms leading from the loop point back to itself.
- Loops connect to each other in an undirected graph.  To explore the entire set of rooms
  in all the loops, just do standard tree embedding.
- Any loop that has no room to itself can be deleted.

If there are n rooms, then there are at most n loops of at most n rooms each, making the
loop graph size O(n^2).  The algorithm finds the next unexplored door in a few linear
passes of this graph.  This solves the maze in O(n^3).

Solving the maze in O(n^3) time requires finding an unexplored door in linear time.  A
nasty map to make this hard looks like:


O>O>O>O>O>O>O>...
^ v v v v v v
^ O-O-O-O-O-O
^ v v v v v v
<<<<<<<<<<<<<

To get to a linear pass to find the next unexplored door, maintain a path from the
beginning of the search to the present.  Any loop in the path is trimmed once there are no
unexplored doors on it.  Keep exploring the most recent loop just traversing max door
labels until we complete a loop without finding an unexplored door.  Delete that last
loop, and follow the most recent loop to this point before that.  If it also has no
unexplored door, delete it.  Repeat until we find the an unexplored door.  This should
lead to a linear time to find the next door, leading to an O(n^2) algorithm.
